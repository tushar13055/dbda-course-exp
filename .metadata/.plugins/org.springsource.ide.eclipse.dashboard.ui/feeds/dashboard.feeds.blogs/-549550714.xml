<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Spring]]></title><description><![CDATA[Level up your Java code and explore what Spring can do for you.]]></description><link>https://spring.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 29 Mar 2023 17:31:55 GMT</lastBuildDate><item><title><![CDATA[Context Propagation with Project Reactor 2 - The bumpy road of Spring Cloud Sleuth]]></title><link>https://spring.io/blog/2023/03/29/context-propagation-with-project-reactor-2-the-bumpy-road-of-spring-cloud</link><guid isPermaLink="true">https://spring.io/blog/2023/03/29/context-propagation-with-project-reactor-2-the-bumpy-road-of-spring-cloud</guid><dc:creator><![CDATA[Dariusz J?drzejczyk]]></dc:creator><pubDate>Wed, 29 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Spring Cloud Sleuth recently &lt;a href=&quot;https://micrometer.io/docs/tracing&quot;&gt;became Micrometer Tracing&lt;/a&gt;, part of the Micrometer project. Most of the tracing instrumentation is centered within Micrometer under the new &lt;a href=&quot;https://micrometer.io/docs/observation&quot;&gt;Observability API&lt;/a&gt;. The goal of these projects is to enable observability of any application – in the form of metrics, tracing, and logs that contain correlation identifiers. To achieve this goal, libraries require a way to transport contextual information. When applications deal with asynchrony in any form, that task becomes quite a challenge. In the previous article, we went through the basics of context propagation with &lt;code&gt;ThreadLocal&lt;/code&gt;s and Reactor &lt;code&gt;Context&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Spring Cloud Sleuth went through many pivots in the approach to asynchronous context propagation. As Sleuth deals with third-party instrumentation libraries that don’t need to have a reactive API, having an established way to make the context available to them is vital. These libraries often don’t assume asynchrony but rely on a static &lt;code&gt;ThreadLocal&lt;/code&gt; state. For years, &lt;code&gt;ThreadLocal&lt;/code&gt;s have provided JVM applications with implicit, contextual storage for driving the observability features. Over time, Project Reactor introduced various hooks and wrapping mechanisms on top of the underlying primitives in order to make the bridging between reactive and imperative possible. In this article, we aim to explore the approaches to propagate context to &lt;code&gt;ThreadLocal&lt;/code&gt; values and discuss the potential errors with them. We’ll explore the approaches Sleuth took and conclude with a summary of what we discovered as a good compromise that is performant and semantically sound.&lt;/p&gt;
&lt;p&gt;Before we describe the approaches that Sleuth introduced, we should consider the dangers that lie in bridging between the imperative and reactive world.&lt;/p&gt;
&lt;h2&gt;Pitfalls of Side Effects in the Face of Hidden Concurrency&lt;/h2&gt;
&lt;p&gt;We discussed some of the potential problems with &lt;code&gt;Thread&lt;/code&gt; switches and related side effects in the previous article. Now we will explore the properties of reactive programming a little more by using Reactor’s plugin mechanism to solve issues that we may encounter.&lt;/p&gt;
&lt;p&gt;To summarize all the issues Spring Cloud Sleuth ran into is a moving target. Also, there are numerous implementations in organizations that implement their own mechanisms for context propagation, for example, for populating SLF4J’s &lt;code&gt;MDC&lt;/code&gt;. This article is not intended to be a comprehensive summary of all the potential pitfalls. It rather aims to build some intuition that will help you understand the ultimate truth: you either play by reactive programming rules or you prepare to lose in the most unexpected moments.&lt;/p&gt;
&lt;h2&gt;Scheduler Hook&lt;/h2&gt;
&lt;p&gt;As we know, reactive chains can propagate signals using different &lt;code&gt;Thread&lt;/code&gt;s. From what we learned in &lt;a href=&quot;https://spring.io/blog/2023/03/28/context-propagation-with-project-reactor-1-the-basics&quot;&gt;the previous article&lt;/a&gt;, when execution is continued on another &lt;code&gt;Thread&lt;/code&gt;, it makes sense to restore the context when a task is run. Project Reactor delegates the task of managing &lt;code&gt;Thread&lt;/code&gt;s to &lt;code&gt;Scheduler&lt;/code&gt;s. It also provides a dedicated hook that allows intercepting the scheduling and running of a particular unit of work: the &lt;code&gt;Schedulers.onScheduleHook&lt;/code&gt;. It works in a similar way as the &lt;code&gt;WrappedExecutor&lt;/code&gt; from the previous article. Let’s see a scenario when we might consider using it.&lt;/p&gt;
&lt;h3&gt;Cleanup&lt;/h3&gt;
&lt;p&gt;In Part 1 we understood that we can’t rely on &lt;code&gt;ThreadLocal&lt;/code&gt; values to be available consistently within a reactive chain. What if we tried to initialize it at subscription time, and clear it in the &lt;code&gt;doFinally&lt;/code&gt; operator?
Our applications can handle many requests, some of them concurrently, using a limited number of &lt;code&gt;Thread&lt;/code&gt;s. As those platform &lt;code&gt;Thread&lt;/code&gt;s can be reused, we need to perform cleanup of any &lt;code&gt;ThreadLocal&lt;/code&gt; state associated with one request before processing another so that a different request does not use a leftover correlation identifier.&lt;/p&gt;
&lt;p&gt;The code samples that follow are alterations to the code we wrote in the previous part, in which we didn’t use the Reactor &lt;code&gt;Context&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A potential implementation of the &lt;code&gt;handleRequest&lt;/code&gt; method could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; handleRequest() {
  return Mono.fromSupplier(() -&gt; {
    initRequest(); // &amp;#x3C;1&gt;
    return &quot;test-product&quot;;
  }).flatMap(product -&gt;
    Flux.concat(
      addProduct(product),
      notifyShop(product)).then())
    .doOnSuccess(v -&gt; log(&quot;Done.&quot;))
    .doFinally(signalType -&gt;
      CORRELATION_ID.remove()); // &amp;#x3C;2&gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;&amp;#x3C;1&gt;&lt;/code&gt; we set the &lt;code&gt;ThreadLocal&lt;/code&gt; value, and in &lt;code&gt;&amp;#x3C;2&gt;&lt;/code&gt; we attempt to clear it.&lt;/p&gt;
&lt;p&gt;We also modify the actions we perform to be able to add an artificial delay in the &lt;code&gt;addProduct&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; addProduct(String productName) {
  return Mono.defer(() -&gt; {
    log(&quot;Adding product: &quot; + productName);
    return Mono.&amp;#x3C;Void&gt;empty()
      .delaySubscription(Duration.ofMillis(10),
        Schedulers.single()); // &amp;#x3C;1&gt;
  });
}

Mono&amp;#x3C;Boolean&gt; notifyShop(String productName) {
  return Mono.defer(() -&gt; {
    log(&quot;Notifying shop about: &quot; + productName);
    return Mono.just(true);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that, in &lt;code&gt;&amp;#x3C;1&gt;&lt;/code&gt;, we introduce asynchrony by delaying the subscription and use &lt;code&gt;Schedulers.single()&lt;/code&gt; to initiate the subscription after 10ms. The &lt;code&gt;delaySubscription&lt;/code&gt; will use that &lt;code&gt;Scheduler&lt;/code&gt;’s underlying &lt;code&gt;ScheduledExecutorService&lt;/code&gt; and initiate the subscription on another &lt;code&gt;Thread&lt;/code&gt; after the delay.&lt;/p&gt;
&lt;p&gt;From the previous article, we know we need to restore &lt;code&gt;ThreadLocals&lt;/code&gt; in such a case, so we use the mentioned &lt;code&gt;Scheduler&lt;/code&gt; plugin to achieve that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Schedulers.onScheduleHook(&quot;context.propagation&quot;, WrappedRunnable::new);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every task executed on Reactor’s &lt;code&gt;Scheduler&lt;/code&gt;s will restore the &lt;code&gt;ThreadLocal&lt;/code&gt; values, so we should be safe.&lt;/p&gt;
&lt;p&gt;Now, let’s imitate two sequential requests, separated by a log validating that &lt;code&gt;CORRELATION_ID&lt;/code&gt; is cleared properly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;log(&quot;Got first request, calling handler&quot;);
handleRequest().block();

log(&quot;Got second request, calling handler&quot;);
log(&quot;There should be no correlationId on this line!&quot;);

handleRequest().block();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The logs are as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][                null] Got first request, calling handler // &amp;#x3C;1&gt;
[      main][ 8658769170992364531] Adding product: test-product
[  single-1][ 8658769170992364531] Notifying shop about: test-product
[  single-1][ 8658769170992364531] Done.
[      main][ 8658769170992364531] Got second request, calling handler
[      main][ 8658769170992364531] There should be no correlationId on this line!
[      main][  711436174608061530] Adding product: test-product
[  single-1][  711436174608061530] Notifying shop about: test-product
[  single-1][  711436174608061530] Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The logs related to &lt;code&gt;“test-product”&lt;/code&gt; processing have correct correlation identifiers. However, what happened in between the requests? We expected to have the &lt;code&gt;ThreadLocal&lt;/code&gt; be cleared in &lt;code&gt;doFinally&lt;/code&gt;. Unfortunately, the log in between requests still contains an identifier. What happened then?&lt;/p&gt;
&lt;p&gt;Notice the &lt;code&gt;“Notifying shop about”&lt;/code&gt; log happened on &lt;code&gt;Thread&lt;/code&gt; &lt;code&gt;single-1&lt;/code&gt;. The signal was delivered on that &lt;code&gt;Thread&lt;/code&gt;, so we cleared the &lt;code&gt;ThreadLocal&lt;/code&gt; there, but left the main &lt;code&gt;Thread&lt;/code&gt; polluted (in &lt;code&gt;&amp;#x3C;1&gt;&lt;/code&gt;). Now the execution outside of our handler can use the wrong correlation identifier for different purposes. We could try to mitigate this issue by adding cleanup logic to the server layer (which dispatches requests) and make sure every &lt;code&gt;Thread&lt;/code&gt; used for a request is not polluted. This wouldn’t save all the other potential &lt;code&gt;Scheduler&lt;/code&gt; &lt;code&gt;Thread&lt;/code&gt;s if our pipeline were more complex.&lt;/p&gt;
&lt;p&gt;This approach gets quite far in allowing an application to use &lt;code&gt;ThreadLocal&lt;/code&gt; values transparently within a reactive chain. It’s also reasonable from a performance perspective, since it does not set and reset &lt;code&gt;ThreadLocal&lt;/code&gt; around every operator, but only when there is a &lt;code&gt;Thread&lt;/code&gt; switch when processing the items. However, it also shows there are side effects that remain unsolved. In the next examples we will experience and attempt to tackle different scenarios.&lt;/p&gt;
&lt;h3&gt;Difficulties with External Sources and Sinks&lt;/h3&gt;
&lt;p&gt;Another common issue for the strategies that use &lt;code&gt;ThreadLocal&lt;/code&gt; as the transport mechanism for contextual metadata is when a different asynchronous library than Reactor is used and it switches &lt;code&gt;Thread&lt;/code&gt;s on its own. When the execution changes to a different &lt;code&gt;Thread&lt;/code&gt; that is not controlled by a wrapped &lt;code&gt;ExecutorService&lt;/code&gt;, the context is lost.&lt;/p&gt;
&lt;p&gt;Let’s see this in action. We will reuse most of the code we’ve seen so far, with one change to the &lt;code&gt;notifyShop&lt;/code&gt; method. It now imitates a remote call by using the following method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Boolean&gt; makeRequest(String productName) {
  return Mono.fromFuture(CompletableFuture.supplyAsync(() -&gt; true,
    CompletableFuture.delayedExecutor(100, TimeUnit.MILLISECONDS)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;notifyShop&lt;/code&gt; looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Boolean&gt; notifyShop(String productName) {
  return Mono.defer(() -&gt; {
    log(&quot;Notifying shop about: &quot; + productName);
    return makeRequest(productName);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we trigger the handler once:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;handleRequest().block();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][  683056557275963407] Adding product: test-product
[  single-1][  683056557275963407] Notifying shop about: test-product
[l-worker-1][                null] Done!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The logs shorten the &lt;code&gt;Thread&lt;/code&gt; names for better visibility, but &lt;code&gt;l-worker-1&lt;/code&gt; is actually a shortened version of &lt;code&gt;ForkJoinPool.commonPool-worker-1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As we can see, our execution continued on a common &lt;code&gt;ForkJoinPool&lt;/code&gt; that we don’t control. One problem is that we no longer see our correlation identifier starting from that &lt;code&gt;Thread&lt;/code&gt; switch, but another is that we perform cleanup on a &lt;code&gt;Thread&lt;/code&gt; that is actually missing the correlation information.&lt;/p&gt;
&lt;p&gt;We could potentially improve the situation (partially) with &lt;code&gt;Executor&lt;/code&gt; or task wrapping, as presented in the previous article, but we don’t always have such control - for example, if we call an external library that uses &lt;code&gt;CompletableFuture&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Operator Hooks&lt;/h2&gt;
&lt;p&gt;We’re almost ready to discuss Sleuth’s strategies. &lt;code&gt;Schedulers.onScheduleHook&lt;/code&gt; offers limited capability with regards to the non-obvious &lt;code&gt;Thread&lt;/code&gt; switches that can happen in reactive processing. We need more control over the execution of operations. We will demonstrate the limitations by introducing two flavors of external service communication.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;addProduct&lt;/code&gt; method now makes a remote request and publishes the result on a &lt;code&gt;Scheduler&lt;/code&gt; we control. It is common to offload heavy computations to a different &lt;code&gt;Thread&lt;/code&gt;. For that purpose, we use the &lt;code&gt;publishOn&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; addProduct(String productName) {
  return Mono.defer(() -&gt; {
    log(&quot;Adding product: &quot; + productName);
    return makeRequest(productName)
      .publishOn(Schedulers.single())
      .then();
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;notifyShop&lt;/code&gt; method emulates mapping the result into potentially multiple &lt;code&gt;Publisher&lt;/code&gt;s. That can be a typical scenario in case the response is a composite result - for example, if the response is a JSON array and we intend to process each item as a separate call to another service or enrich the individual result. Let’s use a simplified version and take only a single result:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Boolean&gt; notifyShop(String productName) {
  return Mono.defer(() -&gt; {
    log(&quot;Notifying shop about: &quot; + productName);
    return makeRequest(productName)
      .flatMapMany(result -&gt;
        Flux.just(&quot;result&quot;)
          .map(x -&gt; result))
          .take(1)
          .single();
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s skip the handler for now and manually initiate the correlation identifiers and then subscribe to these chains:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;initRequest();
addProduct(&quot;test-product&quot;)
  .doOnSuccess(v -&gt; log(&quot;Added.&quot;))
  .block();

initRequest();
notifyShop(&quot;test-product&quot;)
  .doOnSuccess(v -&gt; log(&quot;Notified.&quot;))
  .block();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s see the output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][ 6606077262934500649] Adding product: test-product
[  single-1][                null] Added.
[      main][  182687922231622589] Notifying shop about: test-product
[l-worker-1][                null] Notified.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is expected, as both logs that happen in &lt;code&gt;doOnSuccess&lt;/code&gt; are triggered as a result of the &lt;code&gt;CompletableFuture&lt;/code&gt; delivering the value on a &lt;code&gt;ForkJoinPool&lt;/code&gt; &lt;code&gt;Thread&lt;/code&gt;. Even though we have &lt;code&gt;Scheduler&lt;/code&gt; wrapping, the result is first delivered on a &lt;code&gt;Thread&lt;/code&gt; we don’t control, so even &lt;code&gt;publishOn&lt;/code&gt; used in &lt;code&gt;addProduct&lt;/code&gt; doesn’t help.&lt;/p&gt;
&lt;p&gt;Can we do anything to improve the situation? Reactor has a fine-grained plugin system, which lets us decorate any operator within any pipeline. We can try to use it for the purpose of restoring the correlation identifier.&lt;/p&gt;
&lt;p&gt;The plugins will use a custom &lt;code&gt;Subscriber&lt;/code&gt; implementation, which captures the correlation identifier upon subscription:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static class CorrelatingSubscriber&amp;#x3C;T&gt; implements CoreSubscriber&amp;#x3C;T&gt; {
  final CoreSubscriber&amp;#x3C;T&gt; delegate;
  Long correlationId;

  public CorrelatingSubscriber(CoreSubscriber&amp;#x3C;T&gt; delegate) {
    this.delegate = delegate;
  }

  @Override
  public void onSubscribe(Subscription s) {
    delegate.onSubscribe(s);
    this.correlationId = CORRELATION_ID.get();
  }

  @Override
  public void onNext(T t) {
    CORRELATION_ID.set(this.correlationId);
    delegate.onNext(t);
  }

  @Override
  public void onError(Throwable t) {
    CORRELATION_ID.set(this.correlationId);
    delegate.onError(t);
  }

  @Override
  public void onComplete() {
    CORRELATION_ID.set(this.correlationId);
    delegate.onComplete();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To alter an operator to have our implementation delegate calls to an actual &lt;code&gt;Subscriber&lt;/code&gt; instance, we can use the &lt;code&gt;Operators.lift&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Operators.lift((scannable, subscriber) -&gt;
  new CorrelatingSubscriber&amp;#x3C;&gt;(subscriber));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;onEachOperator Hook&lt;/h3&gt;
&lt;p&gt;First, we’ll try a plugin, which lets us alter every single operator in the chain:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Hooks.onEachOperator(
  Operators.lift((scannable, subscriber) -&gt;
    new CorrelatingSubscriber&amp;#x3C;&gt;(subscriber)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s run our example once more and examine the output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][ 7295088917002526647] Adding product: test-product
[  single-1][ 7295088917002526647] Added.
[      main][  383851863754448684] Notifying shop about: test-product
[l-worker-1][  383851863754448684] Notified.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wow! We managed to get the correlation identifier even in such complicated scenarios. The initial act of subscribing caught the &lt;code&gt;ThreadLocal&lt;/code&gt; value and restored it in each step. Even the &lt;code&gt;flatMap&lt;/code&gt; used in the &lt;code&gt;notifyShop&lt;/code&gt; method (which subscribes on its own) works, because, prior to subscribing on another &lt;code&gt;Thread&lt;/code&gt;, the &lt;code&gt;ThreadLocal&lt;/code&gt; is populated from a previous capture! This does sound wonderful indeed, but there are drawbacks of this approach. The first and most obvious one is performance. The propagation takes place for each and every operator. With that technique, we first decorate every object, as well as make &lt;code&gt;ThreadLocal&lt;/code&gt; accesses in every step. All of them are expensive. To learn more, watch &lt;a href=&quot;https://www.youtube.com/watch?v=pyqIpqCt8PU&quot;&gt;Oleh’s talk about Reactive Performance&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;onLastOperator Hook&lt;/h3&gt;
&lt;p&gt;So let’s try a different approach. This time, we’ll use a plugin that attaches to every operator that is considered the last one in the chain – an operator directly before a &lt;code&gt;subscribe()&lt;/code&gt; call.&lt;/p&gt;
&lt;p&gt;One observation can be made about reactive chains: In the case of synchronous operators, we don’t need to restore the initially captured context in each individual manipulation (for example, &lt;code&gt;filter&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt;) but only when the last operator in the chain is subscribed to. This mechanism works as long as there is no &lt;code&gt;Thread&lt;/code&gt; boundary crossing involved. To support operators that potentially cross these boundaries (such as &lt;code&gt;flatMap&lt;/code&gt;, which involves subscribing to a new &lt;code&gt;Publisher&lt;/code&gt;), there is a special trick involved. It treats the results of the mapping as the last operators for the internal &lt;code&gt;Publishers&lt;/code&gt; that they operate on.&lt;/p&gt;
&lt;p&gt;Let’s try this approach:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Hooks.onLastOperator(
  Operators.lift((scannable, subscriber) -&gt;
    new CorrelatingSubscriber&amp;#x3C;&gt;(subscriber)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][ 2122332013640150746] Adding product: test-product
[  single-1][ 2122332013640150746] Added.
[      main][  459477771449275997] Notifying shop about: test-product
[l-worker-1][                null] Notified.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It worked with &lt;code&gt;publishOn&lt;/code&gt; in &lt;code&gt;addProduct&lt;/code&gt; but fails for the &lt;code&gt;flatMap&lt;/code&gt; in &lt;code&gt;notifyShop&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let’s analyze why &lt;code&gt;notifyShop&lt;/code&gt; fails. Our call to &lt;code&gt;block()&lt;/code&gt; captures the &lt;code&gt;ThreadLocal&lt;/code&gt; and restores it for every signal traveling downstream. With the mapping done in &lt;code&gt;flatMapMany&lt;/code&gt;, we are dealing with an asynchronous boundary that we mentioned before. Our plugin is, in fact, applied to the internal source (&lt;code&gt;Flux.just().map().single()&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;However, these efforts still didn’t help, despite the fact that the custom &lt;code&gt;Subscriber&lt;/code&gt; is called internally in &lt;code&gt;flatMapMany&lt;/code&gt; and tries to restore the &lt;code&gt;ThreadLocal&lt;/code&gt; value. The signal triggering the internal subscription was initiated on a &lt;code&gt;Thread&lt;/code&gt; we don’t control, so we have no &lt;code&gt;ThreadLocal&lt;/code&gt; to capture in the first place.&lt;/p&gt;
&lt;p&gt;It is different in the case of the &lt;code&gt;publishOn&lt;/code&gt; operator. The subscription to it begins in a &lt;code&gt;Thread&lt;/code&gt; we control. Therefore, when a signal is processed as a result from the &lt;code&gt;makeRequest()&lt;/code&gt; method, it is only delivered on a &lt;code&gt;Thread&lt;/code&gt; that is in our control. The execution of &lt;code&gt;.doOnSuccess(v -&gt; log(&quot;Added.&quot;))&lt;/code&gt; happens after a different &lt;code&gt;Thread&lt;/code&gt; boundary than in the case of &lt;code&gt;flatMapMany&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;That’s why &lt;code&gt;onEachOperator&lt;/code&gt; covers more cases - it restores the initial value at each step, regardless of asynchronous boundaries. The performance is slightly better with &lt;code&gt;onLastOperator&lt;/code&gt; than with &lt;code&gt;onEachOperator&lt;/code&gt; though.&lt;/p&gt;
&lt;h3&gt;addQueueWrapper Hook&lt;/h3&gt;
&lt;p&gt;There is one more plugin that we can use to get full control over the reactive delivery if we combine it with the previous hooks. It is also used by Spring Cloud Sleuth. We are thinking about a recently introduced plugin, &lt;code&gt;Hooks.addQueueWrapper&lt;/code&gt;. We will not explore it in detail, though. It can solve the problem introduced by a work-stealing mechanism in Reactor. Asynchronous operators, such as &lt;code&gt;flatMap&lt;/code&gt;, can make progress on various &lt;code&gt;Thread&lt;/code&gt;s that deliver signals to the operator. Imagine a backpressure scenario where the processing is stalled for a while. At some point, a new &lt;code&gt;Thread&lt;/code&gt; can take over and issue a &lt;code&gt;Subscription.request(n)&lt;/code&gt; call, which causes the accumulated values to be delivered immediately. Now you can ask yourself: “what accumulated values?” That is a good question. A lot of operators in Reactor use internal &lt;code&gt;Queue&lt;/code&gt;s to make backpressure possible or to preserve the serial delivery semantics. Because the draining of these &lt;code&gt;Queue&lt;/code&gt;s can happen on any &lt;code&gt;Thread&lt;/code&gt;, the contextual information should be attached to every signal stored in the &lt;code&gt;Queue&lt;/code&gt; - namely, the &lt;code&gt;ThreadLocal&lt;/code&gt; value for our correlation purposes. That’s what we’d need a &lt;code&gt;Queue&lt;/code&gt; wrapper for - upon submitting a value into the &lt;code&gt;Queue&lt;/code&gt;, we capture the &lt;code&gt;ThreadLocal&lt;/code&gt; state. When a value is retrieved from the &lt;code&gt;Queue&lt;/code&gt;, the state is restored.&lt;/p&gt;
&lt;h2&gt;Context Propagation in Spring Cloud Sleuth&lt;/h2&gt;
&lt;p&gt;Having shown what are the risks of operating outside of the reactive-streams terms and what mechanisms we can use to propagate &lt;code&gt;ThreadLocal&lt;/code&gt; context, let’s summarize the four &lt;a href=&quot;https://docs.spring.io/spring-cloud-sleuth/docs/current-SNAPSHOT/reference/html/integrations.html#sleuth-reactor-integration&quot;&gt;strategies used by Spring Cloud Sleuth&lt;/a&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;DECORATE_ON_EACH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DECORATE_ON_LAST&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DECORATE_QUEUES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MANUAL&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first three strategies try to use some properties of reactive operators, together with Reactor’s &lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#hooks-assembly&quot;&gt;plugin mechanism&lt;/a&gt;, and use &lt;code&gt;ThreadLocal&lt;/code&gt;s as the internal transport mechanism as well as the means to share the contextual data with instrumentation libraries. The first three strategies also assume &lt;code&gt;Scheduler&lt;/code&gt; wrapping with &lt;a href=&quot;https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#onScheduleHook-java.lang.String-java.util.function.Function-&quot;&gt;Schedulers.onScheduleHook&lt;/a&gt;. On the other hand, the last strategy takes advantage of Reactor’s &lt;code&gt;Subscriber&lt;/code&gt;-bound &lt;code&gt;Context&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;DECORATE_ON_EACH&lt;/h3&gt;
&lt;p&gt;This strategy uses the &lt;a href=&quot;https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Hooks.html#onEachOperator-java.util.function.Function-&quot;&gt;&lt;code&gt;Hooks.onEachOperator&lt;/code&gt;&lt;/a&gt; plugin we’ve seen in action before.
The performance impact is dramatic, even though Sleuth adds a lot of optimizations to avoid restoration when not necessary.
Usually, this method is very effective. It is very aggressive though, so it can be troublesome to cope with if an operator requires changing the context. The downstream operators wouldn’t see a change, as the context from the initial subscription is restored at each step.&lt;/p&gt;
&lt;h3&gt;DECORATE_ON_LAST&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Hooks.html#onLastOperator-java.util.function.Function-&quot;&gt;&lt;code&gt;Hooks.onLastOperator&lt;/code&gt;&lt;/a&gt; is used to improve performance.
This approach can fail because of the flexibility it provides. If an upstream operator modifies the context, the downstream operations see the change. This carries the risk that, if an operator clears that context, that context is lost until another signal is scheduled to the wrapped &lt;code&gt;Scheduler&lt;/code&gt;.
Another risk is what we’ve seen in the earlier examples, where the subscription happens on some &lt;code&gt;Thread&lt;/code&gt;, but requesting the data happens on another, which is not in Reactor’s control.&lt;/p&gt;
&lt;h3&gt;DECORATE_QUEUES&lt;/h3&gt;
&lt;p&gt;An evolution over the preceding strategy, &lt;code&gt;DECORATE_QUEUES&lt;/code&gt; corrects some erroneous scenarios (requesting data happens out-of-band or multiple &lt;code&gt;Threads&lt;/code&gt; publish data) but not all of them. The &lt;a href=&quot;https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Hooks.html#addQueueWrapper-java.lang.String-java.util.function.Function-&quot;&gt;&lt;code&gt;Hooks.addQueueWrapper&lt;/code&gt;&lt;/a&gt; plugin is used the way we described earlier.
One known issue with &lt;code&gt;Queue&lt;/code&gt; wrapping is that there is no reliable way of cleaning up after the processing of an item. The context is restored upon retrieval of an item from a &lt;code&gt;Queue&lt;/code&gt;. There is no scope surrounding processing of the item that travels through downstream operators. Therefore, this approach is also prone to polluting &lt;code&gt;ThreadLocal&lt;/code&gt; storage. There have been some recent improvements in the draining procedure to limit the impact.&lt;/p&gt;
&lt;h3&gt;MANUAL&lt;/h3&gt;
&lt;p&gt;In this strategy, the only thing Sleuth does is to capture the values from &lt;code&gt;ThreadLocal&lt;/code&gt;s into Reactor’s &lt;code&gt;Context&lt;/code&gt; upon subscription as a snapshot. It is up to the user to extract that snapshot in relevant places and populate the &lt;code&gt;ThreadLocal&lt;/code&gt;s to make them available to instrumenting libraries. For supported tracing instrumentation, such as with Zipkin and Brave, Sleuth restores the &lt;code&gt;ThreadLocal&lt;/code&gt;s by using a concept of scoping – the &lt;code&gt;ThreadLocal&lt;/code&gt;s are restored for the instrumentation and are gone immediately after the snapshot is closed.
It is the most performant approach, although it requires manual (as the name suggests) handling, by the user.&lt;/p&gt;
&lt;h2&gt;Evolution&lt;/h2&gt;
&lt;p&gt;Using Reactor Context to populate &lt;code&gt;ThreadLocal&lt;/code&gt;s in a localized scope proves to be both performant and compliant with the way the reactive chains work. Associating context with the &lt;code&gt;Subscriber&lt;/code&gt; is a proven approach that does not unexpectedly cause the contextual data to be lost. In the next article, we will show how Reactor 3.5 and Micrometer 1.10 took the manual approach to the next level and provide a structured approach to context propagation across reactive and imperative boundaries.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[This Week in Spring - March 28th, 202]]></title><link>https://spring.io/blog/2023/03/28/this-week-in-spring-march-28th-202</link><guid isPermaLink="true">https://spring.io/blog/2023/03/28/this-week-in-spring-march-28th-202</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Tue, 28 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hi, Spring fans! Welcome to another installment of &lt;em&gt;This Week in Spring&lt;/em&gt;! I&apos;m reporting to you from Los Angeles, where my family and I have gone for my daughter&apos;s spring break. We&apos;re going to survey some prospective colleges and we&apos;re going to Disneyland. Needless to say, I&apos;m doubly glad to have all this cool stuff to read this week; I can really savor each article! Let&apos;s dive in!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/03/28/context-propagation-with-project-reactor-1-the-basics&quot;&gt;Context Propagation with Project Reactor 1 - The Basics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://feeds.feedblitz.com/~/732762194/0/baeldung~Introduction-to-Grafana-Loki&quot;&gt;Introduction to Grafana Loki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jdk.java.net/20/release-notes&quot;&gt;JDK 20 Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Not Spring Boot, &lt;em&gt;per se&lt;/em&gt;, but this is interesting if you&apos;re developing against Kubernetes and want a quick introduction:  &lt;a href=&quot;https://feeds.feedblitz.com/~/732761111/0/baeldung~Lightweight-Kubernetes-Distributions&quot;&gt;Lightweight Kubernetes Distributions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://feeds.feedblitz.com/~/732562607/0/baeldung~Run-a-Spring-Boot-Application-in-AWS-Lambda&quot;&gt;Run a Spring Boot Application in AWS Lambda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://feeds.feedblitz.com/~/732761114/0/baeldung~SAML-with-Spring-Boot-and-Spring-Security&quot;&gt;SAML with Spring Boot and Spring Security&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/03/23/spring-boot-2-7-10-available-now&quot;&gt;Spring Boot 2.7.10 available now&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/03/27/spring-integration-for-aws-3-0-0-m2-and-spring-cloud-stream-kinesis-binder-4&quot;&gt;Spring Integration for AWS 3.0.0-M2 and Spring Cloud Stream Kinesis Binder 4.0.0-M1 Available&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://feeds.feedblitz.com/~/732423968/0/baeldung~Spring-Kafka-Configure-Multiple-Listeners-on-Same-Topic&quot;&gt;Spring Kafka: Configure Multiple Listeners on Same Topic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/03/24/spring-modulith-0-5-1-released&quot;&gt;Spring Modulith 0.5.1 released&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=SjSjBZ7mo1g&quot;&gt;Spring Modulith – Spring for the Architecturally Curious Developer by Oliver Drotbohm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://feeds.feedblitz.com/~/732559919/0/baeldung~Spring-RDBC-Migrations-Using-Flyway&quot;&gt;Spring R2DBC Migrations Using Flyway&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://spring.io/blog/2023/03/22/start-from-zero-and-scale-to-zero-azure-spring-apps-consumption-plan&quot;&gt;Start from zero and scale to zero – Azure Spring Apps consumption plan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;I loved  this article about different tools that you can use in your CI environment - like Snyk and Dependabot - to &lt;a href=&quot;https://maritvandijk.com/using-bots-to-keep-our-dependencies-up-to-date/&quot;&gt;keep bots up-to-date with dependencies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/JavaAtMicrosoft/status/1638637078551605248&quot;&gt;Start from 0 and scale to 0 for the most efficient resource utilization and simplify networking for your polyglot apps with the Azure Spring Apps consumption plan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Spring Cloud AWS lead Maciej Walkowiak put together a nice library called the   &lt;a href=&quot;https://github.com/maciejwalkowiak/spring-boot-startup-report&quot;&gt;Spring Boot Startup Report library generates an interactive Spring Boot application startup report that lets you understand what contributes to the application startup time and perhaps helps to optimize it.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Context Propagation with Project Reactor 1 - The Basics]]></title><link>https://spring.io/blog/2023/03/28/context-propagation-with-project-reactor-1-the-basics</link><guid isPermaLink="true">https://spring.io/blog/2023/03/28/context-propagation-with-project-reactor-1-the-basics</guid><dc:creator><![CDATA[Dariusz J?drzejczyk]]></dc:creator><pubDate>Tue, 28 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Spring Boot 3 and Spring Framework 6 &lt;a href=&quot;https://spring.io/blog/2022/10/12/observability-with-spring-boot-3&quot;&gt;brought us&lt;/a&gt; a unified and consistent way to enable Observability in applications that use Micrometer. The evolution from Spring Cloud Sleuth to Micrometer, along with the Observation API and Micrometer Tracing, made us consolidate various approaches to context propagation. In this blog post series, we aim to explain how we came to support context propagation in Project Reactor to meet the needs of imperative libraries. By building your understanding from the ground up, you will be able to use these constructs and understand what’s happening underneath. We assume basic understanding of reactive programming concepts. If you’re new to it or want to refresh your knowledge, have a look at &lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#intro-reactive&quot;&gt;Introduction to Reactive Programming&lt;/a&gt; in the Project Reactor documentation.&lt;/p&gt;
&lt;p&gt;In this article, we develop a simple e-commerce application. Our limited angle considers a request that adds a product and notifies the shop that a new product was added to the inventory. As responsible developers, we want to log all the steps taken for a particular request so that, if we were to investigate a problem, we can look at the logs and understand what happened. We’ll explore how we can achieve the goal of providing the logging utility with contextual metadata about the request in an imperative style and also compare that to a more functional, declarative style of Project Reactor. The next articles will explore in more detail why and how we need a bridge between both programming styles.&lt;/p&gt;
&lt;h2&gt;ThreadLocal&lt;/h2&gt;
&lt;p&gt;To identify the logs belonging to a particular request, we need a way to correlate them. We may generate a simplistic random identifier like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static long correlationId() {
  return Math.abs(ThreadLocalRandom.current().nextLong());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need a way to make the correlation identifier be available in a logging utility. We could make the correlation part of every method call in our business logic, but that would be very invasive and verbose.&lt;/p&gt;
&lt;p&gt;Usually, third-party libraries use JDK’s &lt;code&gt;ThreadLocal&lt;/code&gt; to convey implicit information that is not the primary concern of our application’s business logic.&lt;/p&gt;
&lt;p&gt;Let’s declare a static field for our correlation identifier:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static final ThreadLocal&amp;#x3C;Long&gt; CORRELATION_ID = new ThreadLocal&amp;#x3C;&gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here’s our log method. It prints the current &lt;code&gt;Thread&lt;/code&gt; name and formats the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static void log(String message) {
  String threadName = Thread.currentThread().getName();
  String threadNameTail = threadName.substring(
    Math.max(0, threadName.length() - 10));
  System.out.printf(&quot;[%10s][%20s] %s%n&quot;,
    threadNameTail, CORRELATION_ID.get(), message);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have everything we need to handle the request and log each step by using the implicit correlation identifier.&lt;/p&gt;
&lt;p&gt;At the beginning of every request, the application makes a call to the following method to initiate the correlation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static void initRequest() {
  CORRELATION_ID.set(correlationId()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our simplified request handler performs the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void handleRequest() {
  initRequest();

  addProduct(&quot;test-product&quot;);
  notifyShop(&quot;test-product&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Logging in the business logic looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;void addProduct(String productName) {
  log(&quot;Adding product: &quot; + productName);
  // ...
}

void notifyShop(String productName) {
  log(&quot;Notifying shop about: &quot; + productName);
  // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can expect our application to log these lines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][ 8592000019542134146] Adding product: test-product
[      main][ 8592000019542134146] Notifying shop about: test-product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As long as the execution of a particular request happens on the same &lt;code&gt;Thread&lt;/code&gt; and is not interleaved with other concerns, &lt;code&gt;ThreadLocal&lt;/code&gt; lets us decouple business logic from the metadata used for logging.&lt;/p&gt;
&lt;h2&gt;Asynchronous Processing&lt;/h2&gt;
&lt;p&gt;Let’s imagine this application starts to have a higher load and needs to handle many concurrent requests. Imagine that we can use an asynchronous and non-blocking server implementation that requires us to provide asynchronous declarations instead of imperative and blocking steps.&lt;/p&gt;
&lt;p&gt;Our request handler could return a &lt;code&gt;CompletableFuture&lt;/code&gt; to process the request in an asynchronous and non-blocking manner:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;CompletableFuture&amp;#x3C;Void&gt; handleRequest() {
  return CompletableFuture
    .runAsync(() -&gt; addProduct(&quot;test-product&quot;))
    .thenRunAsync(() -&gt; notifyShop(&quot;test-product&quot;))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, when we execute our asynchronous version, the logs no longer contain the correlation identifier:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[l-worker-1][                null] Adding product: test-product
[l-worker-1][                null] Notifying shop about: test-product
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Task Wrapping&lt;/h2&gt;
&lt;p&gt;A known mitigation for this issue is to wrap the tasks executed by asynchronous APIs. By wrapping, we mean an implementation that performs the restoration of the &lt;code&gt;ThreadLocal&lt;/code&gt; context. When the task is created, the current context is captured. When a worker &lt;code&gt;Thread&lt;/code&gt; actually executes the task, that context is restored. Let’s see how this would work for our example case with &lt;code&gt;Runnable&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class WrappedRunnable implements Runnable {

  private final Long correlationId;
  private final Runnable wrapped;

  public WrappedRunnable(Runnable wrapped) {
    this.correlationId = CORRELATION_ID.get();
    this.wrapped = wrapped;
  }

  @Override
  public void run() {
    Long old = CORRELATION_ID.get();
    CORRELATION_ID.set(this.correlationId);
    try {
      wrapped.run();
    } finally {
      CORRELATION_ID.set(old);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could reimplement our handler like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;CompletableFuture&amp;#x3C;Void&gt; handleRequest() {
  return CompletableFuture
    .runAsync(new WrappedRunnable(
      () -&gt; addProduct(&quot;test-product&quot;)))
    .thenRunAsync(new WrappedRunnable(
      () -&gt; notifyShop(&quot;test-product&quot;)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unfortunately, that is a lot of overhead. Luckily, the JDK has an API for executing asynchronous tasks: the &lt;code&gt;Executor&lt;/code&gt; interface. In a real-world scenario, we’d want to use a more comprehensive API, the &lt;code&gt;ExecutorService&lt;/code&gt;. However, for our explanatory purposes, &lt;code&gt;Executor&lt;/code&gt; should suffice.&lt;/p&gt;
&lt;p&gt;Let’s have a look:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static class WrappedExecutor implements Executor {

  private final Executor actual;

  WrappedExecutor(Executor actual) {
    this.actual = actual;
  }

  @Override
  public void execute(Runnable command) {
    actual.execute(new WrappedRunnable(command));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s reuse the common &lt;code&gt;ForkJoinPool&lt;/code&gt; that the &lt;code&gt;CompletableFuture&lt;/code&gt; framework uses by default, but wrap it with our implementation.
Now our code looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static Executor executor = new WrappedExecutor(ForkJoinPool.commonPool());

CompletableFuture&amp;#x3C;Void&gt; handleRequest() {
  return CompletableFuture
    .runAsync(() -&gt; addProduct(&quot;test-product&quot;), executor)
    .thenRunAsync(() -&gt; notifyShop(&quot;test-product&quot;), executor);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our logs again work properly:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[l-worker-1][ 7321040639376081961] Adding product: test-product
[l-worker-2][ 7321040639376081961] Notifying shop about: test-product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In some scenarios, the &lt;code&gt;CompletableFuture&lt;/code&gt; framework can provide the means to process asynchronous tasks in a non-blocking fashion. However, in many cases, the limited API surface and its behavior characteristics can be limiting. For example, we might want to delay the processing and resume later when our system is at its capacity. With &lt;code&gt;CompletableFuture&lt;/code&gt; all created instances start computing as soon as they are created. We might also want to apply more fine grained operations on top of a stream of data, instead of operating upon a single unit of computation. For some of those reasons and also more, we might consider using a reactive programming library. We will consider Project Reactor, which is the default reactive implementation in the Spring portfolio.&lt;/p&gt;
&lt;h2&gt;Project Reactor&lt;/h2&gt;
&lt;p&gt;To provide a resilient framework for asynchronous processing, the Java community proposed the Reactive Streams specification. It helped establish a common vocabulary that the JDK was missing before – clear semantics for signal propagation, error handling, termination, and lifecycle management. It also allowed for built-in backpressure. Spring adopted this approach by introducing WebFlux, making Project Reactor and its reactive types first class citizens of the API.&lt;/p&gt;
&lt;p&gt;Reactive Streams bring elegant and minimalistic solutions for asynchronous stream processing. However, context propagation is not part of the specification. The non-blocking and asynchronous nature of reactive libraries, together with potentially complex implementations, makes it extremely difficult to use &lt;code&gt;ThreadLocal&lt;/code&gt;s. The reason for it is that there are no guarantees regarding which &lt;code&gt;Thread&lt;/code&gt; can run the user’s code. Implementations are allowed to perform all sorts of optimizations as long as they guarantee serial delivery, thus making the user’s code concurrency-agnostic, shifting the burden of dealing with concurrency to the library internals.&lt;/p&gt;
&lt;p&gt;To deliver its guarantees, reactive programming in Java assumes the functional programming paradigm is used to form a declarative and composable flow, which is agnostic of the fact that different &lt;code&gt;Thread&lt;/code&gt;s can execute user-provided code. The reactive libraries can provide an extremely performant runtime, while complying to the specification, as long as there are no side effects in user code that assume execution within a particular &lt;code&gt;Thread&lt;/code&gt;. &lt;code&gt;ThreadLocal&lt;/code&gt; clearly violates this requirement.&lt;/p&gt;
&lt;p&gt;Let’s try to rewrite our handler to use Project Reactor. The individual operations become:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; addProduct(String productName) {
  log(&quot;Adding product: &quot; + productName);
  return Mono.empty(); // Assume we’re actually storing the product
}

Mono&amp;#x3C;Boolean&gt; notifyShop(String productName) {
  log(&quot;Notifying shop about: &quot; + productName);
  return Mono.just(true); // Assume we’re actually notifying the shop
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s try to use the above:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; handleRequest() {
  initRequest();
  log(&quot;Invoke methodAssembling the to get Mono chain&quot;);

  return Mono.just(&quot;test-product&quot;)
    .flatMap(product -&gt;
      Flux.concat(
        addProduct(product),
        notifyShop(product))
      .then())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our naive implementation yields the desired output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][ 7224499961623309444] Assembling the chain
[      main][ 7224499961623309444] Adding product: test-product
[      main][ 7224499961623309444] Notifying shop about: test-product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above implementation is invoked in the &lt;code&gt;main&lt;/code&gt; &lt;code&gt;Thread&lt;/code&gt;, and the execution is confined to that &lt;code&gt;Thread&lt;/code&gt;. We should not make such assumptions though.&lt;/p&gt;
&lt;p&gt;In the handler, we introduce a slight delay before we propagate the result of the processing. We do so to demonstrate the implicit &lt;code&gt;Thread&lt;/code&gt; switch that happens behind the scenes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; handleRequest() {
  initRequest(); &amp;#x3C;1&gt;
  log(&quot;Assembling the chain&quot;); // &amp;#x3C;2&gt;

  return Mono.just(&quot;test-product&quot;)
    .delayElement(Duration.ofMillis(1)) // &amp;#x3C;3&gt;
    .flatMap(product -&gt;
      Flux.concat(
        addProduct(product), // &amp;#x3C;4&gt;
        notifyShop(product))
      .then())
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When run, the following is printed:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][ 6265915299594887150] Assembling the chain
[parallel-1][                null] Adding product: test-product
[parallel-1][                null] Notifying shop about: test-product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What happened? Why does one log have the correlation identifier but the others don’t?&lt;/p&gt;
&lt;p&gt;When the server calls our handler, the initialization at &lt;code&gt;&amp;#x3C;1&gt;&lt;/code&gt; sets the &lt;code&gt;ThreadLocal&lt;/code&gt; correlation identifier and the log at &lt;code&gt;&amp;#x3C;2&gt;&lt;/code&gt; is able to use it. Those experienced in reactive programming can tell you the issue is that the execution happens in different phases. The &lt;code&gt;ThreadLocal&lt;/code&gt; is set at assembly time. “You should restore it at subscription time, too” would be one piece of advice. We’ll get back to that in a bit. If the terms “assembly”, “subscription”, and “execution time” are confusing to you, have a look at the excellent explanations in &lt;a href=&quot;https://spring.io/blog/2019/03/06/flight-of-the-flux-1-assembly-vs-subscription&quot;&gt;Simon’s blog post&lt;/a&gt; or watch &lt;a href=&quot;https://www.youtube.com/watch?v=sNgTTcG-fEU&quot;&gt;the talk of the same title&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While the method is returned immediately it does not guarantee that execution is started. That is because the returned &lt;code&gt;Mono&lt;/code&gt; has to be subscribed to trigger processing. It may potentially happen in a different &lt;code&gt;Thread&lt;/code&gt;. The &lt;code&gt;delayElement&lt;/code&gt; operator at &lt;code&gt;&amp;#x3C;3&gt;&lt;/code&gt; implicitly uses a shared &lt;code&gt;Scheduler&lt;/code&gt; (an abstraction for a pool of &lt;code&gt;Thread&lt;/code&gt;s) from Reactor to deliver the signal on yet another &lt;code&gt;Thread&lt;/code&gt; after the specified delay. That signal propagates to the downstream operators, which let us sequence adding the product first and notifying the shop afterwards. There are more surprising aspects of the pipeline we assembled, but let’s not get too confused.&lt;/p&gt;
&lt;p&gt;The issue is that, in &lt;code&gt;&amp;#x3C;4&gt;&lt;/code&gt;, if we log, we can’t really tell what &lt;code&gt;Thread&lt;/code&gt; the call is going to happen on. Operators such as &lt;code&gt;flatMap&lt;/code&gt; can introduce their own asynchrony.&lt;/p&gt;
&lt;p&gt;In a regular case, values start being delivered when the chain is subscribed to. We could therefore restore &lt;code&gt;ThreadLocal&lt;/code&gt; values upon every subscription. It’s not always the best idea though. The &lt;code&gt;Subscription&lt;/code&gt; can be delivered asynchronously, on a different &lt;code&gt;Thread&lt;/code&gt;. Also values can be delivered on different &lt;code&gt;Thread&lt;/code&gt;s. In the case of backpressure, a signal can be delivered as a result of a request for more data on the &lt;code&gt;Thread&lt;/code&gt; performing the request instead of the &lt;code&gt;Thread&lt;/code&gt; used by the &lt;code&gt;Publisher&lt;/code&gt; of data. Lots of moving parts and quirks to consider! To learn more about threading and asynchronous execution in Reactor please review &lt;a href=&quot;https://spring.io/blog/2019/12/13/flight-of-the-flux-3-hopping-threads-and-schedulers&quot;&gt;another part of our previous blog post series&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Reactor Context&lt;/h2&gt;
&lt;p&gt;Project Reactor introduced a mechanism that is well aligned with functional programming to provide means to transport contextual metadata. It is simply called &lt;code&gt;Context&lt;/code&gt;. And it stays attached to the reactive chain, despite Thread switches that happen behind the scenes.&lt;/p&gt;
&lt;p&gt;As we’ve seen, Project Reactor allows declaratively specifying the intent, while staying concurrency agnostic. It does provide the means to control concurrency when necessary, by using dedicated operators or configuration parameters (such as &lt;code&gt;publishOn&lt;/code&gt;, &lt;code&gt;subscribeOn&lt;/code&gt;, or the advanced parameters of &lt;code&gt;flatMap&lt;/code&gt;), but that level of control is abstracted away from the core processing logic.&lt;/p&gt;
&lt;p&gt;We mentioned side effects earlier. How can we get rid of those and still be able to transport contextual metadata?&lt;/p&gt;
&lt;p&gt;To play well with functional programming, the &lt;code&gt;Context&lt;/code&gt; is bound to the &lt;code&gt;Subscriber&lt;/code&gt;, the consumer of signals emitted by the &lt;code&gt;Publisher&lt;/code&gt;. Upon subscription, a &lt;code&gt;Subscriber&lt;/code&gt; is made visible to all preceding operators in the assembled pipeline. When we associate an immutable &lt;code&gt;Map&lt;/code&gt;-like data structure to the &lt;code&gt;Subscriber&lt;/code&gt; instance, it allows attaching and retrieving contextual information in parts of a reactive pipeline.&lt;/p&gt;
&lt;p&gt;With control of the impact and the means to provide inheritance between steps in the reactive chain, Reactor &lt;code&gt;Context&lt;/code&gt; is a side-effect-free concept, which can be used to provide meta-information to the processing. “Just what we need to correlate our requests!”.&lt;/p&gt;
&lt;p&gt;Let’s rewrite our application to use Reactor &lt;code&gt;Context&lt;/code&gt; instead of &lt;code&gt;ThreadLocal&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;First, we need to make the correlation identifier an explicit parameter of the log method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;static void log(String message, long correlationId) {
  String threadName = Thread.currentThread().getName();
  String threadNameTail = threadName.substring(
    Math.max(0, threadName.length() - 10));
  System.out.printf(&quot;[%10s][%20s] %s%n&quot;,
    threadNameTail, correlationId, message);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our actions are the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; addProduct(String productName) {
  return Mono.deferContextual(ctx -&gt; {
    log(&quot;Adding product: &quot; + productName, ctx.get(&quot;CORRELATION_ID&quot;));
    return Mono.empty(); // Assume we’re actually storing the product
  });
}

Mono&amp;#x3C;Boolean&gt; notifyShop(String productName) {
  return Mono.deferContextual(ctx -&gt; {
    log(&quot;Notifying shop about: &quot; + productName,
      ctx.get(&quot;CORRELATION_ID&quot;));
    return Mono.just(true);
  });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What is interesting is how we provide the correlation identifier. We use a special operator, &lt;code&gt;Mono.deferContextual&lt;/code&gt;, which has access to the &lt;code&gt;Context&lt;/code&gt;. From the &lt;code&gt;ContextView&lt;/code&gt; (a simplified, read-only &lt;code&gt;Context&lt;/code&gt; version) we extract the correlation identifier before returning an actual &lt;code&gt;Mono&lt;/code&gt; for the caller to subscribe to.&lt;/p&gt;
&lt;p&gt;Our handler looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Mono&amp;#x3C;Void&gt; handleRequest() {
  long correlationId = correlationId();
  log(&quot;Assembling the chain&quot;, correlationId);

  Mono.just(&quot;test-product&quot;)
    .delayElement(Duration.ofMillis(1))
    .flatMap(product -&gt;
      Flux.concat(addProduct(product), notifyShop(product))
          .then())
    .contextWrite(Context.of(&quot;CORRELATION_ID&quot;, correlationId));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When subscribed to, the output is as expected:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[      main][ 6328001264807824115] Assembling the chain
[parallel-1][ 6328001264807824115] Adding product: test-product
[parallel-1][ 6328001264807824115] Notifying shop about: test-product
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The inversion of information flow is apparent. As in any reactive chain, we define the processing flow by assembling a chain of operators. Once we (or actually, the server) subscribe to this chain, the information flows from downstream operators to the upstream operators to initiate the processing. Afterwards, the actual data signals are delivered from the upstream to the downstream – for example, the “test-product” value travels to the &lt;code&gt;flatMap&lt;/code&gt; operator, then to the &lt;code&gt;concat&lt;/code&gt; operator, which in turn provides the value to both &lt;code&gt;addProduct&lt;/code&gt; and &lt;code&gt;notifyShop&lt;/code&gt;. Due to this flow of logic, we write the &lt;code&gt;Context&lt;/code&gt; at the very end (using the &lt;code&gt;contextWrite&lt;/code&gt; method), just before any &lt;code&gt;Subscriber&lt;/code&gt; subscribes to the chain. We can imagine the &lt;code&gt;Context&lt;/code&gt; then becomes accessible alongside the &lt;code&gt;Subscriber&lt;/code&gt; to all the stages in upstream operators.&lt;/p&gt;
&lt;p&gt;Regardless of how many thread hops the reactive pipeline makes along the way of executing the user’s business logic, the context is not lost.&lt;/p&gt;
&lt;p&gt;You can read more about Reactor &lt;code&gt;Context&lt;/code&gt; &lt;a href=&quot;https://projectreactor.io/docs/core/release/reference/#context&quot;&gt;in our documentation&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;3rd party libraries&lt;/h2&gt;
&lt;p&gt;Unfortunately, we can’t expect 3rd party libraries to use Reactor &lt;code&gt;Context&lt;/code&gt; to provide observability capabilities. The de facto currency for propagating implicit meta-information is the &lt;code&gt;ThreadLocal&lt;/code&gt;. Libraries like SLF4J use an imperative style and have a stable position in the Java community. If we can make them work with the reactive paradigm instead of expecting them to adapt to it, it would be a clear win. In the next part, we discuss the history and challenges of propagating &lt;code&gt;ThreadLocal&lt;/code&gt; values in reactive chains in Spring Cloud Sleuth, a tracing library that can be used together with Reactor.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Integration for AWS 3.0.0-M2 and Spring Cloud Stream Kinesis Binder 4.0.0-M1 Available]]></title><link>https://spring.io/blog/2023/03/27/spring-integration-for-aws-3-0-0-m2-and-spring-cloud-stream-kinesis-binder-4</link><guid isPermaLink="true">https://spring.io/blog/2023/03/27/spring-integration-for-aws-3-0-0-m2-and-spring-cloud-stream-kinesis-binder-4</guid><dc:creator><![CDATA[Artem Bilan]]></dc:creator><pubDate>Mon, 27 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Dear Spring community,&lt;/p&gt;
&lt;p&gt;Today I&apos;m excited to share with you news that &lt;a href=&quot;https://github.com/spring-projects/spring-integration-aws&quot;&gt;Spring Integration extension project for AWS&lt;/a&gt; and &lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-stream-binder-aws-kinesis&quot;&gt;AWS Kinesis Binder for Spring Cloud Stream&lt;/a&gt; have finally been moved to &lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-java/latest/developer-guide/home.html&quot;&gt;AWS Java SDK v2&lt;/a&gt;, their respective milestones &lt;code&gt;3.0.0-M2&lt;/code&gt; &amp;#x26; &lt;code&gt;4.0.0-M1&lt;/code&gt; are available from Spring Milestone repository.&lt;/p&gt;
&lt;p&gt;I cannot tell that this was a pleasant work to do because it has turned to be not just a plain dependencies upgrade and namespace renaming. The whole AWS SDK API was changed to more modern Java style, including &lt;code&gt;CompletableFuture&lt;/code&gt; composition and &lt;code&gt;Stream&lt;/code&gt; API, lambda-style configuration, generated builders etc. They have even Reactive Streams support! Some options have been removed and some added. So, even if Spring Integration channel adapters are high enough API for end-users, they still suffered many breaking changes with these new generations.&lt;/p&gt;
&lt;p&gt;Some highlights of these milestone:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Of course, first of all the latest AWS SDK &lt;code&gt;2.20.32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Upgrades to &lt;a href=&quot;https://awspring.io/&quot;&gt;Spring Cloud AWS&lt;/a&gt; &lt;code&gt;3.0.0&lt;/code&gt; with its new SQS listener API&lt;/li&gt;
&lt;li&gt;XML configuration removal. Right, this is unusual for Spring backwards compatibility, but Spring Cloud AWS did that already and there is no any Spring Cloud projects providing and XML support.&lt;/li&gt;
&lt;li&gt;Our own &lt;code&gt;DynamoDbLockRegistry&lt;/code&gt; implementation with a proper TTL support.&lt;/li&gt;
&lt;li&gt;KCL channel adapter now relies on a new &lt;a href=&quot;https://docs.aws.amazon.com/streams/latest/dev/building-enhanced-consumers-kcl.html&quot;&gt;Enhanced Fan-Out Consumer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;All outbound channel adapters are &lt;code&gt;async&lt;/code&gt; by default and leverage a &lt;code&gt;CompletableFuture&lt;/code&gt; support from their super &lt;code&gt;AbstractMessageProducingHandler&lt;/code&gt; class.&lt;/li&gt;
&lt;li&gt;The &lt;a href=&quot;https://docs.aws.amazon.com/glue/latest/dg/schema-registry.html&quot;&gt;Glue Schema&lt;/a&gt; support has been exposed in KCL and KPL channel adapters.&lt;/li&gt;
&lt;li&gt;The Kinesis Binder does not support &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.KCLAdapter.html&quot;&gt;DynamoDB Streams Adapter&lt;/a&gt; any more. There is no its implementation for SDK v2 and general AWS recommendation is to use Kinesis &lt;a href=&quot;https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/kds.html&quot;&gt;enabled on the table&lt;/a&gt; to  captures data changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See READMEs of these projects on GitHub for more information.&lt;/p&gt;
&lt;p&gt;We are probably going to GA in a couple weeks, so don&apos;t hesitate to give them a try and come back with any feedback or contribution!&lt;/p&gt;
&lt;p&gt;Cheers, &lt;br&gt;
Artem&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-integration/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-integration/issues&quot;&gt;GitHub Issues&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.adoc&quot;&gt;Contributing&lt;/a&gt; | &lt;a href=&quot;http://stackoverflow.com/questions/tagged/spring-integration&quot;&gt;Help&lt;/a&gt; | &lt;a href=&quot;https://gitter.im/spring-projects/spring-integration&quot;&gt;Chat&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Boot 3.1.0-M2 available now]]></title><link>https://spring.io/blog/2023/03/24/spring-boot-3-1-0-m2-available-now</link><guid isPermaLink="true">https://spring.io/blog/2023/03/24/spring-boot-3-1-0-m2-available-now</guid><dc:creator><![CDATA[Andy Wilkinson]]></dc:creator><pubDate>Fri, 24 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, I&apos;m happy to announce that Spring Boot &lt;code&gt;3.1.0-M2&lt;/code&gt; has been released and is now available from &lt;a href=&quot;https://repo.spring.io/milestone&quot;&gt;https://repo.spring.io/milestone&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This release includes &lt;a href=&quot;https://github.com/spring-projects/spring-boot/releases/tag/v3.1.0-M2&quot;&gt;81 enhancements, documentation improvements, dependency upgrades, and bug fixes&lt;/a&gt;. Notable new features include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Auto-configuration for Spring Authorization Service&lt;/li&gt;
&lt;li&gt;Improved Testcontainers integration&lt;/li&gt;
&lt;li&gt;Improved auto-configuration for Spring for GraphQL&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please see the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.1.0-M2-Release-Notes&quot;&gt;release notes&lt;/a&gt; for more details and upgrade instructions.&lt;/p&gt;
&lt;p&gt;Thanks to all those who have contributed with issue reports and pull requests.&lt;/p&gt;
&lt;h3&gt;How can you help?&lt;/h3&gt;
&lt;p&gt;If you&apos;re interested in helping out, check out the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/labels/status%3A%20ideal-for-contribution&quot;&gt;&quot;ideal for contribution&quot; tag&lt;/a&gt; in the issue repository. If you have general questions, please ask on &lt;a href=&quot;https://stackoverflow.com&quot;&gt;stackoverflow.com&lt;/a&gt; using the &lt;a href=&quot;https://stackoverflow.com/tags/spring-boot&quot;&gt;&lt;code&gt;spring-boot&lt;/code&gt; tag&lt;/a&gt; or chat with the community on &lt;a href=&quot;https://gitter.im/spring-projects/spring-boot&quot;&gt;Gitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-boot/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-boot&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-boot/issues&quot;&gt;Issues&lt;/a&gt; | &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/3.1.0-M2/reference/html&quot;&gt;Documentation&lt;/a&gt; | &lt;a href=&quot;https://stackoverflow.com/questions/tagged/spring-boot&quot;&gt;Stack Overflow&lt;/a&gt; | &lt;a href=&quot;https://gitter.im/spring-projects/spring-boot&quot;&gt;Gitter&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Modulith 0.5.1 released]]></title><link>https://spring.io/blog/2023/03/24/spring-modulith-0-5-1-released</link><guid isPermaLink="true">https://spring.io/blog/2023/03/24/spring-modulith-0-5-1-released</guid><dc:creator><![CDATA[Oliver Drotbohm]]></dc:creator><pubDate>Fri, 24 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I&apos;d like to announce the availability of Spring Modulith 0.5.1. The release primarily contains an important bug fix (the &lt;code&gt;spring-modulith-runtime&lt;/code&gt; module accidentally contained a Logback configuration file only intended for test usage) and the usual upgrade to the latest Spring Boot version. Find more information in the &lt;a href=&quot;https://github.com/spring-projects-experimental/spring-modulith/releases/tag/0.5.1&quot;&gt;full changelog&lt;/a&gt;, as well as &lt;a href=&quot;https://docs.spring.io/spring-modulith/docs/0.5.1/reference/html/&quot;&gt;reference documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In case you are wondering about what the project is all about, Voxxed Days Zurich have published &quot;Spring Modulith – Spring for Architecturally Curious Developers&quot;:&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/SjSjBZ7mo1g&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; allowfullscreen&gt;&lt;/iframe&gt;</content:encoded></item><item><title><![CDATA[Spring for Apache Pulsar 0.2.0 available now]]></title><link>https://spring.io/blog/2023/03/24/spring-for-apache-pulsar-0-2-0-available-now</link><guid isPermaLink="true">https://spring.io/blog/2023/03/24/spring-for-apache-pulsar-0-2-0-available-now</guid><dc:creator><![CDATA[Chris Bono]]></dc:creator><pubDate>Fri, 24 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, I’m happy to announce that Spring for Apache Pulsar &lt;code&gt;0.2.0&lt;/code&gt; has been released and is now available from &lt;a href=&quot;https://repo1.maven.org/maven2/org/springframework/pulsar/spring-pulsar-spring-boot-starter/0.2.0&quot;&gt;Maven Central&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is the second GA minor release of the framework. Although &lt;code&gt;0.2.0&lt;/code&gt; still lives in the experimental Spring projects it is in the process of moving into the main Spring projects as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The core will move into spring-projects/spring-pulsar (targeting mid-April)&lt;/li&gt;
&lt;li&gt;The autoconfiguration will move into spring-projects/spring-boot (targeting the Spring Boot &lt;code&gt;3.2.0&lt;/code&gt; release)&lt;/li&gt;
&lt;li&gt;The binder will move into spring-cloud/spring-cloud-stream (targeting the SCSt &lt;code&gt;4.1.0&lt;/code&gt; release)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Notable Changes&lt;/h2&gt;
&lt;p&gt;We have been busy adding features since our &lt;a href=&quot;https://spring.io/blog/2022/12/15/spring-for-apache-pulsar-0-1-0-available-now&quot;&gt;last blog&lt;/a&gt;. Notable new features include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring Boot &lt;code&gt;3.0.5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Apache Pulsar &lt;code&gt;2.11.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Apache Pulsar Reactive client &lt;code&gt;0.2.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Spring Cloud Stream Pulsar binder (AOT enabled)&lt;/li&gt;
&lt;li&gt;Pulsar IO / Pulsar Functions support&lt;/li&gt;
&lt;li&gt;Pulsar header mapper (w/ encoding and filtering)&lt;/li&gt;
&lt;li&gt;Default type mappings (topics + schema info)&lt;/li&gt;
&lt;li&gt;Pulsar Reader support&lt;/li&gt;
&lt;li&gt;Tombstone support&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Please see the &lt;a href=&quot;https://github.com/spring-projects-experimental/spring-pulsar/releases/tag/0.2.0&quot;&gt;release notes&lt;/a&gt; for more detail.&lt;/p&gt;
&lt;p&gt;A great place to get started is the &lt;a href=&quot;https://docs.spring.io/spring-pulsar/docs/0.2.0/reference/html/#quick-tour&quot;&gt;Quick Tour&lt;/a&gt; in the reference docs.&lt;/p&gt;
&lt;h3&gt;How can you help?&lt;/h3&gt;
&lt;p&gt;If you&apos;re interested in helping out, check out the &lt;a href=&quot;https://github.com/spring-projects-experimental/spring-pulsar/labels/status%3A%20ideal-for-contribution&quot;&gt;&quot;ideal for contribution&quot; tag&lt;/a&gt; in the issue repository. If you have general questions, please ask on Stack Overflow using the &lt;a href=&quot;https://stackoverflow.com/tags/spring-pulsar&quot;&gt;&lt;code&gt;spring-pulsar&lt;/code&gt; tag&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spring-projects-experimental/spring-pulsar&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects-experimental/spring-pulsar/issues&quot;&gt;Issues&lt;/a&gt; | &lt;a href=&quot;https://docs.spring.io/spring-pulsar/docs/0.2.0/reference/html&quot;&gt;Documentation&lt;/a&gt; | &lt;a href=&quot;https://stackoverflow.com/tags/spring-pulsar&quot;&gt;Stack Overflow&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[A Bootiful Podcast:  Mark Thomas, Apache Tomcat contributor extraordinaire]]></title><link>https://spring.io/blog/2023/03/23/a-bootiful-podcast-mark-thomas-apache-tomcat-contributor-extraordinaire</link><guid isPermaLink="true">https://spring.io/blog/2023/03/23/a-bootiful-podcast-mark-thomas-apache-tomcat-contributor-extraordinaire</guid><dc:creator><![CDATA[Josh Long]]></dc:creator><pubDate>Thu, 23 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;iframe title=&quot;Apache Tomcat contributor extraordinaire Mark Thomas&quot; allowtransparency=&quot;true&quot; height=&quot;150&quot; width=&quot;100%&quot; style=&quot;border: none; min-width: min(100%, 430px);&quot; scrolling=&quot;no&quot; data-name=&quot;pb-iframe-player&quot; src=&quot;https://www.podbean.com/player-v2/?i=yh962-13c4e27-pb&amp;from=pb6admin&amp;share=1&amp;download=1&amp;rtl=0&amp;fonts=Arial&amp;skin=1&amp;font-color=&amp;logo_link=episode_page&amp;btn-skin=7&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;Hi, Spring fans! Welcome to another installment of A Bootiful Podcast! In this installment, Josh Long talks to longtime Apache Tomcat contributor extraordinaire Mark Thomas&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I wrote a free white paper on using Spring Boot 3 AOT and GraalVM. Learn the secrets to working with Spring Boot 3 and GraalVM native images  &lt;a href=&quot;https://tanzu.vmware.com/content/white-papers/spring-boot-3&quot;&gt;https://tanzu.vmware.com/content/white-papers/spring-boot-3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;I did a Spring Tips installment on using Vaadin and Spring Boot 3 together, along with the shiny new AOT support &lt;a href=&quot;https://www.youtube.com/watch?v=nyR-qzj7O3w&quot;&gt;https://www.youtube.com/watch?v=nyR-qzj7O3w&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java 20 is out! the last one to install it is a rotten egg! Get the bits NOW! &lt;a href=&quot;https://twitter.com/java/status/1638195008162471936&quot;&gt;https://twitter.com/java/status/1638195008162471936&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Want to learn Spring Boot 3? Check out this video I did for the Jetbrains channel a few weeks ago &lt;a href=&quot;https://www.youtube.com/watch?v=Y2gZz8-yK7Y&quot;&gt;https://www.youtube.com/watch?v=Y2gZz8-yK7Y&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Spring Integration 5.5.17, 6.0.4 and 6.1.0-M2 Available]]></title><link>https://spring.io/blog/2023/03/23/spring-integration-5-5-17-6-0-4-and-6-1-0-m2-available</link><guid isPermaLink="true">https://spring.io/blog/2023/03/23/spring-integration-5-5-17-6-0-4-and-6-1-0-m2-available</guid><dc:creator><![CDATA[Artem Bilan]]></dc:creator><pubDate>Thu, 23 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Dear Spring community,&lt;/p&gt;
&lt;p&gt;On behalf of the team, it is my pleasure to announce that Spring Integration &lt;code&gt;6.1.0-M2&lt;/code&gt; is now available from Spring Milestone repository.&lt;/p&gt;
&lt;p&gt;In addition bug fixes versions &lt;code&gt;5.5.17&lt;/code&gt; and &lt;code&gt;6.0.4&lt;/code&gt; have been released.
They also include upgrades to the latest point versions of dependencies with their bug fixes.&lt;/p&gt;
&lt;p&gt;The Spring Integration &lt;code&gt;6.1&lt;/code&gt; version is a natural evolution of &lt;code&gt;6.x&lt;/code&gt; generation with fixes and improvements which didn&apos;t make it into &lt;code&gt;6.0&lt;/code&gt;.
Plus we listen to community and make some possibly but convenient for target projects breaking changes.&lt;/p&gt;
&lt;p&gt;Some highlights of this new version include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Upgrades to the latest dependencies, but only if they don&apos;t break the public API we expose&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Added Protobuf transformers support (shout out to &lt;a href=&quot;https://spring.io/team/tzolov&quot;&gt;Christian Tzolov&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Migration of Zip extension to respective module in the core project&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;MessageFilter&lt;/code&gt; now emits a WARN log when a request message is dropped making it, technically, not silent as it was before&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Now gateways and replying handlers don&apos;t block forever for sending and receiving operations.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The default timeout in the framework is chosen to be &lt;code&gt;30&lt;/code&gt; seconds&lt;/p&gt;
&lt;p&gt;See &lt;a href=&quot;https://docs.spring.io/spring-integration/docs/6.1.0-M2/reference/html/whats-new.html#whats-new&quot;&gt;What&apos;s New&lt;/a&gt; in the documentation and don&apos;t forget about a &lt;a href=&quot;https://github.com/spring-projects/spring-integration/wiki/Spring-Integration-6.0-to-6.1-Migration-Guide&quot;&gt;Migration Guide&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Following Spring Boot release cadence we are going to have Spring Integration &lt;code&gt;6.1.0-RC1&lt;/code&gt; in April and then GA in May - just for upcoming Spring Boot &lt;code&gt;3.1.0&lt;/code&gt;. Feel free to contribute whatever you find valuable!&lt;/p&gt;
&lt;p&gt;Cheers, &lt;br&gt;
Artem&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://projects.spring.io/spring-integration/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-integration/issues&quot;&gt;GitHub Issues&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-integration/blob/master/CONTRIBUTING.adoc&quot;&gt;Contributing&lt;/a&gt; | &lt;a href=&quot;http://stackoverflow.com/questions/tagged/spring-integration&quot;&gt;Help&lt;/a&gt; | &lt;a href=&quot;https://gitter.im/spring-projects/spring-integration&quot;&gt;Chat&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Boot 3.0.5 available now]]></title><link>https://spring.io/blog/2023/03/23/spring-boot-3-0-5-available-now</link><guid isPermaLink="true">https://spring.io/blog/2023/03/23/spring-boot-3-0-5-available-now</guid><dc:creator><![CDATA[Andy Wilkinson]]></dc:creator><pubDate>Thu, 23 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, I&apos;m happy to announce that Spring Boot &lt;code&gt;3.0.5&lt;/code&gt; has been released and is now available from Maven Central.&lt;/p&gt;
&lt;p&gt;This release includes &lt;a href=&quot;https://github.com/spring-projects/spring-boot/releases/tag/v3.0.5&quot;&gt;40 bug fixes, documentation improvements, and dependency upgrades&lt;/a&gt;. Thanks to all those who have contributed with issue reports and pull requests.&lt;/p&gt;
&lt;h3&gt;Java 20 Support&lt;/h3&gt;
&lt;p&gt;Following the GA release of Java 20 earlier this week, Spring Boot 3.0.5 adds support for Java 20.&lt;/p&gt;
&lt;h3&gt;How can you help?&lt;/h3&gt;
&lt;p&gt;If you&apos;re interested in helping out, check out the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/labels/status%3A%20ideal-for-contribution&quot;&gt;&quot;ideal for contribution&quot; tag&lt;/a&gt; in the issue repository. If you have general questions, please ask on &lt;a href=&quot;https://stackoverflow.com&quot;&gt;stackoverflow.com&lt;/a&gt; using the &lt;a href=&quot;https://stackoverflow.com/tags/spring-boot&quot;&gt;&lt;code&gt;spring-boot&lt;/code&gt; tag&lt;/a&gt; or chat with the community on &lt;a href=&quot;https://gitter.im/spring-projects/spring-boot&quot;&gt;Gitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-boot/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-boot&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-boot/issues&quot;&gt;Issues&lt;/a&gt; | &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/3.0.5/reference/html&quot;&gt;Documentation&lt;/a&gt; | &lt;a href=&quot;https://stackoverflow.com/questions/tagged/spring-boot&quot;&gt;Stack Overflow&lt;/a&gt; | &lt;a href=&quot;https://gitter.im/spring-projects/spring-boot&quot;&gt;Gitter&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>